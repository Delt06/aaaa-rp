#pragma kernel CS

#ifndef KERNEL_NAME
#define KERNEL_NAME CS
#endif

#define THREAD_GROUP_SIZE 16

// Sources:
// - Kaplanyan, Anton. (2009). Light Propagation Volumes in CryEngine 3.
// - https://github.com/mafian89/Light-Propagation-Volumes/blob/master/shaders/lightInject.frag
// - https://ericpolman.com/2016/06/28/light-propagation-volumes/

#include_with_pragmas "Packages/com.deltation.aaaa-rp/ShaderLibrary/Bindless.hlsl"

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Depth.hlsl"

float4 _RSMResolution;
float4 _LightDirectionWS;
float4 _LightColor;

TYPED_TEXTURE2D(float4, _RSMPositionMap);
TYPED_TEXTURE2D(float2, _RSMNormalMap);
TYPED_TEXTURE2D(float3, _RSMFluxMap);

RWByteAddressBuffer _GridRedUAV;
RWByteAddressBuffer _GridGreenUAV;
RWByteAddressBuffer _GridBlueUAV;
RWByteAddressBuffer _GridBlockingPotentialUAV;

#define NORMAL_DEPTH_BIAS 0.25
#define LIGHT_DEPTH_BIAS 0.25

RsmOutput FetchRSM(const uint2 texelID)
{
    RsmOutput output;
    output.positionWS = LOAD_TEXTURE2D_LOD(_RSMPositionMap, texelID, 0).xyz;
    output.packedNormalWS = LOAD_TEXTURE2D_LOD(_RSMNormalMap, texelID, 0).xy;
    output.flux = LOAD_TEXTURE2D_LOD(_RSMFluxMap, texelID, 0).xyz;
    return output;
}

void Accumulate(RWByteAddressBuffer buffer, const uint baseAddress, const LPV_PACKED_CHANNEL_T value)
{
    UNITY_UNROLL
    for (uint i = 0; i < 4; ++i)
    {
        buffer.InterlockedAdd(baseAddress + i * 4, asuint(value[i]));
    }
}

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void KERNEL_NAME(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint2 rsmTexelID = dispatchThreadID.xy;
    if (any(rsmTexelID >= _RSMResolution.xy))
    {
        return;
    }

    const RsmValue rsmValue = RsmValue::Unpack(FetchRSM(rsmTexelID));

    float3 gridPositionWS = rsmValue.positionWS;
    gridPositionWS += rsmValue.normalWS * NORMAL_DEPTH_BIAS;
    gridPositionWS += _LightDirectionWS.xyz * LIGHT_DEPTH_BIAS;

    const uint3 resultCellID = LPV::ComputeCellID(gridPositionWS);
    const uint  gridSize = LPV::GetGridSize();

    UNITY_BRANCH
    if (all(resultCellID < gridSize))
    {
        const static float         surfelWeight = 0.015;
        const float3               flux = rsmValue.flux * _LightColor.rgb;
        const float                NdotL = saturate(dot(_LightDirectionWS, rsmValue.normalWS));
        const LPV_CHANNEL_T        shCoefficients = NdotL * surfelWeight * INV_PI * LPVMath::DirToCosineLobe(-rsmValue.normalWS);
        const LPV_PACKED_CHANNEL_T packedRedSH = LPVMath::PackChannelValue(shCoefficients * flux.r);
        const LPV_PACKED_CHANNEL_T packedGreenSH = LPVMath::PackChannelValue(shCoefficients * flux.g);
        const LPV_PACKED_CHANNEL_T packedBlueSH = LPVMath::PackChannelValue(shCoefficients * flux.b);

        const uint flatResultCellID = LPV::FlattenCellID(resultCellID);
        const uint resultAddress = LPV::FlatCellIDToBufferAddress(flatResultCellID);
        Accumulate(_GridRedUAV, resultAddress, packedRedSH);
        Accumulate(_GridGreenUAV, resultAddress, packedGreenSH);
        Accumulate(_GridBlueUAV, resultAddress, packedBlueSH);
    }
}