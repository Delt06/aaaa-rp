#pragma kernel CS

#pragma multi_compile _ BLOCKING_POTENTIAL

#define THREAD_GROUP_SIZE 8

// Sources:
// - Kaplanyan, Anton. (2009). Light Propagation Volumes in CryEngine 3.
// - https://github.com/mafian89/Light-Propagation-Volumes/blob/master/shaders/lightInject.frag
// - https://ericpolman.com/2016/06/28/light-propagation-volumes/

#include_with_pragmas "Packages/com.deltation.aaaa-rp/ShaderLibrary/Bindless.hlsl"

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Depth.hlsl"

float4 _RSMResolution;
float4 _LightDirectionWS;
float4 _LightColor;
float2 _Biases;

TYPED_TEXTURE2D(float4, _RSMPositionMap);
TYPED_TEXTURE2D(float2, _RSMNormalMap);
TYPED_TEXTURE2D(float3, _RSMFluxMap);

RWByteAddressBuffer _GridRedUAV;
RWByteAddressBuffer _GridGreenUAV;
RWByteAddressBuffer _GridBlueUAV;
RWByteAddressBuffer _GridBlockingPotentialUAV;

#define LIGHT_DEPTH_BIAS (_Biases.x)
#define NORMAL_DEPTH_BIAS (_Biases.y)

RsmOutput FetchRSM(const uint2 texelID)
{
    RsmOutput output;
    output.positionWS = LOAD_TEXTURE2D_LOD(_RSMPositionMap, texelID, 0).xyz;
    output.packedNormalWS = LOAD_TEXTURE2D_LOD(_RSMNormalMap, texelID, 0).xy;
    output.flux = LOAD_TEXTURE2D_LOD(_RSMFluxMap, texelID, 0).xyz;
    return output;
}

float3 ComputeBiasedGridPositionWS(const RsmValue rsmValue)
{
    float3 gridPositionWS = rsmValue.positionWS;
    gridPositionWS += rsmValue.normalWS * NORMAL_DEPTH_BIAS;
    gridPositionWS += _LightDirectionWS.xyz * LIGHT_DEPTH_BIAS;
    return gridPositionWS;
}

void Accumulate(RWByteAddressBuffer buffer, const uint baseAddress, const LPV_PACKED_CHANNEL_T value)
{
    UNITY_UNROLL
    for (uint i = 0; i < 4; ++i)
    {
        buffer.InterlockedAdd(baseAddress + i * 4, asuint(value[i]));
    }
}

void AccumulateRadiance(const int3 cellID, const LPV_CHANNEL_T shCoefficients, const float3 flux)
{
    UNITY_BRANCH
    if (all(0 <= cellID && cellID < LPV::GetGridSize()))
    {
        const LPV_PACKED_CHANNEL_T packedRedSH = LPVMath::PackChannelValue(shCoefficients * flux.r);
        const LPV_PACKED_CHANNEL_T packedGreenSH = LPVMath::PackChannelValue(shCoefficients * flux.g);
        const LPV_PACKED_CHANNEL_T packedBlueSH = LPVMath::PackChannelValue(shCoefficients * flux.b);

        const uint flatResultCellID = LPV::FlattenCellID(cellID);
        const uint resultAddress = LPV::FlatCellIDToBufferAddress(flatResultCellID);
        Accumulate(_GridRedUAV, resultAddress, packedRedSH);
        Accumulate(_GridGreenUAV, resultAddress, packedGreenSH);
        Accumulate(_GridBlueUAV, resultAddress, packedBlueSH);
    }
}

void AccumulateBlockingPotential(const int3 cellID, const LPV_CHANNEL_T shCoefficients, const float blockingPotential)
{
    UNITY_BRANCH
    if (all(0 <= cellID && cellID < LPV::GetGridSize()))
    {
        const LPV_PACKED_CHANNEL_T packedSH = LPVMath::PackChannelValue(shCoefficients * blockingPotential);

        const uint flatResultCellID = LPV::FlattenCellID(cellID);
        const uint resultAddress = LPV::FlatCellIDToBufferAddress(flatResultCellID);
        Accumulate(_GridBlockingPotentialUAV, resultAddress, packedSH);
    }
}

#define SURFEL_WEIGHT (5 * _RSMResolution.z)

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint2 rsmTexelID = dispatchThreadID.xy;
    if (any(rsmTexelID >= _RSMResolution.xy))
    {
        return;
    }

    const RsmValue rsmValue = RsmValue::Unpack(FetchRSM(rsmTexelID));

    const float         NdotL = saturate(dot(_LightDirectionWS, rsmValue.normalWS));
    const LPV_CHANNEL_T normalSH = LPVMath::DirToCosineLobe(-rsmValue.normalWS);
    const float3        gridPositionWS = ComputeBiasedGridPositionWS(rsmValue);

    {
        const float3        flux = rsmValue.flux * _LightColor.rgb;
        const LPV_CHANNEL_T shCoefficients = NdotL * SURFEL_WEIGHT * INV_PI * normalSH;
        const float3        resultCellID = LPV::ComputeCellIDFloat(gridPositionWS);
        AccumulateRadiance(resultCellID, shCoefficients, flux);
    }

    #ifdef BLOCKING_POTENTIAL
    {
        const float3 resultCellID = LPV::ComputeBlockingPotentialCellIDRawFloat(gridPositionWS);
        const float  invCellSize = LPV::GetGridSize() / (_LPVGridBoundsMax.x - _LPVGridBoundsMin.x);
        const float  blockingPotential = saturate(NdotL * SURFEL_WEIGHT * invCellSize * invCellSize);
        AccumulateBlockingPotential(resultCellID, normalSH, blockingPotential);
    }
    #endif
}