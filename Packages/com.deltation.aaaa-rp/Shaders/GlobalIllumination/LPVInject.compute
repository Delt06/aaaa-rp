#pragma kernel CS

#pragma multi_compile _ BLOCKING_POTENTIAL

#define THREAD_GROUP_SIZE 16

// Sources:
// - Kaplanyan, Anton. (2009). Light Propagation Volumes in CryEngine 3.
// - https://github.com/mafian89/Light-Propagation-Volumes/blob/master/shaders/lightInject.frag
// - https://ericpolman.com/2016/06/28/light-propagation-volumes/

#include_with_pragmas "Packages/com.deltation.aaaa-rp/ShaderLibrary/Bindless.hlsl"

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Depth.hlsl"

float4 _RSMResolution;
float4 _LightDirectionWS;
float4 _LightColor;
float2 _Biases;

TYPED_TEXTURE2D(float4, _RSMPositionMap);
TYPED_TEXTURE2D(float2, _RSMNormalMap);
TYPED_TEXTURE2D(float3, _RSMFluxMap);

RWByteAddressBuffer _GridRedUAV;
RWByteAddressBuffer _GridGreenUAV;
RWByteAddressBuffer _GridBlueUAV;
RWByteAddressBuffer _GridBlockingPotentialUAV;

#define LIGHT_DEPTH_BIAS (_Biases.x)
#define NORMAL_DEPTH_BIAS (_Biases.y)

RsmOutput FetchRSM(const uint2 texelID)
{
    RsmOutput output;
    output.positionWS = LOAD_TEXTURE2D_LOD(_RSMPositionMap, texelID, 0).xyz;
    output.packedNormalWS = LOAD_TEXTURE2D_LOD(_RSMNormalMap, texelID, 0).xy;
    output.flux = LOAD_TEXTURE2D_LOD(_RSMFluxMap, texelID, 0).xyz;
    return output;
}

void Accumulate(RWByteAddressBuffer buffer, const uint baseAddress, const LPV_PACKED_CHANNEL_T value)
{
    UNITY_UNROLL
    for (uint i = 0; i < 4; ++i)
    {
        buffer.InterlockedAdd(baseAddress + i * 4, asuint(value[i]));
    }
}

#define SURFEL_WEIGHT 0.015

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint2 rsmTexelID = dispatchThreadID.xy;
    if (any(rsmTexelID >= _RSMResolution.xy))
    {
        return;
    }

    const RsmValue rsmValue = RsmValue::Unpack(FetchRSM(rsmTexelID));

    const float         NdotL = saturate(dot(_LightDirectionWS, rsmValue.normalWS));
    const LPV_CHANNEL_T normalSH = LPVMath::DirToCosineLobe(-rsmValue.normalWS);

    float3 gridPositionWS = rsmValue.positionWS;
    gridPositionWS += rsmValue.normalWS * NORMAL_DEPTH_BIAS;
    gridPositionWS += _LightDirectionWS.xyz * LIGHT_DEPTH_BIAS;

    {
        const int3 resultCellID = LPV::ComputeCellID(gridPositionWS);

        UNITY_BRANCH
        if (all(0 <= resultCellID && resultCellID < LPV::GetGridSize()))
        {
            const float3               flux = rsmValue.flux * _LightColor.rgb;
            const LPV_CHANNEL_T        shCoefficients = NdotL * SURFEL_WEIGHT * INV_PI * normalSH;
            const LPV_PACKED_CHANNEL_T packedRedSH = LPVMath::PackChannelValue(shCoefficients * flux.r);
            const LPV_PACKED_CHANNEL_T packedGreenSH = LPVMath::PackChannelValue(shCoefficients * flux.g);
            const LPV_PACKED_CHANNEL_T packedBlueSH = LPVMath::PackChannelValue(shCoefficients * flux.b);

            const uint flatResultCellID = LPV::FlattenCellID(resultCellID);
            const uint resultAddress = LPV::FlatCellIDToBufferAddress(flatResultCellID);
            Accumulate(_GridRedUAV, resultAddress, packedRedSH);
            Accumulate(_GridGreenUAV, resultAddress, packedGreenSH);
            Accumulate(_GridBlueUAV, resultAddress, packedBlueSH);
        }
    }

    #ifdef BLOCKING_POTENTIAL
    {
        const int3 resultCellID = LPV::ComputeBlockingPotentialCellID(gridPositionWS);

        UNITY_BRANCH
        if (all(0 <= resultCellID && resultCellID < LPV::GetGridSize()))
        {
            const float                invCellSize = LPV::GetGridSize() / (_LPVGridBoundsMax.x - _LPVGridBoundsMin.x);
            const float                blockingPotential = saturate(NdotL * SURFEL_WEIGHT * invCellSize * invCellSize);
            const LPV_PACKED_CHANNEL_T packedSH = LPVMath::PackChannelValue(normalSH * blockingPotential);

            const uint flatResultCellID = LPV::FlattenCellID(resultCellID);
            const uint resultAddress = LPV::FlatCellIDToBufferAddress(flatResultCellID);
            Accumulate(_GridBlockingPotentialUAV, resultAddress, packedSH);
        }
    }
    #endif
}