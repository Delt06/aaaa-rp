#pragma kernel CS

#pragma multi_compile_local _ BLOCKING_POTENTIAL
#pragma multi_compile_local _ FIRST_STEP

// Sources:
// - https://github.com/mafian89/Light-Propagation-Volumes/blob/master/shaders/propagation.frag
// - https://ericpolman.com/2016/06/28/light-propagation-volumes/

#define SIDE_FACE_CONTRIBUTION 1
#define DIRECT_FACE_CONTRIBUTION 1

#include_with_pragmas "Packages/com.deltation.aaaa-rp/ShaderLibrary/Bindless.hlsl"

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Lighting.hlsl"

#define THREAD_GROUP_SIZE 4

TYPED_TEXTURE3D(LPV_CHANNEL_T, _SourceRedSH);
TYPED_TEXTURE3D(LPV_CHANNEL_T, _SourceGreenSH);
TYPED_TEXTURE3D(LPV_CHANNEL_T, _SourceBlueSH);

RWTexture3D<LPV_CHANNEL_T> _DestinationRedSH;
RWTexture3D<LPV_CHANNEL_T> _DestinationGreenSH;
RWTexture3D<LPV_CHANNEL_T> _DestinationBlueSH;

float _Intensity;
float _OcclusionAmplification;

TYPED_TEXTURE3D(LPV_CHANNEL_T, _BlockingPotentialSH);

#define DIRECTIONS_COUNT 6
static const float3 directions[DIRECTIONS_COUNT] =
{float3(0, 0, 1), float3(0, 0, -1), float3(1, 0, 0), float3(-1, 0, 0), float3(0, 1, 0), float3(0, -1, 0)};

// right up
int2 cellSides[4] = {int2(1.0, 0.0), int2(0.0, 1.0), int2(-1.0, 0.0), int2(0.0, -1.0)};

float3 GetEvalSideDirection(int index, int3 orientation)
{
    const static float smallComponent = 0.4472135; // 1 / sqrt(5)
    const static float bigComponent = 0.894427; // 2 / sqrt(5)

    const int2   side = cellSides[index];
    const float3 tmp = float3(side.x * smallComponent, side.y * smallComponent, bigComponent);
    return float3(orientation.x * tmp.x, orientation.y * tmp.y, orientation.z * tmp.z);
}

float3 GetReprojSideDirection(int index, int3 orientation)
{
    const int2 side = cellSides[index];
    return float3(orientation.x * side.x, orientation.y * side.y, 0);
}

float CalculateOcclusion(const LPV_CHANNEL_T blockingPotentialSH, const LPV_CHANNEL_T directionSH)
{
    #if defined(BLOCKING_POTENTIAL) && !defined(FIRST_STEP)
    return 1 - saturate(_OcclusionAmplification * dot(blockingPotentialSH, directionSH));
    #else
    return 1;
    #endif
}

float4 EvalPropagatedSH(const LPV_CHANNEL_T neighborSH, const LPV_CHANNEL_T evalDirectionSH, const LPV_CHANNEL_T cosineLobeSH)
{
    return max(0, dot(neighborSH, evalDirectionSH)) * cosineLobeSH;
}

LPV_CHANNEL_T FetchSourceSH(const TYPED_TEXTURE3D(LPV_CHANNEL_T, tex), const uint3 neighbourID)
{
    return tex[neighbourID];
}

LPV_CHANNEL_T FetchBlockingPotential(const float3 neighbourID)
{
    const float3 uv = neighbourID / LPV::GetGridSize();
    return SAMPLE_TEXTURE3D_LOD(_BlockingPotentialSH, sampler_TrilinearClamp, uv, 0);
}

void Accumulate(RWTexture3D<LPV_CHANNEL_T> destination, const TYPED_TEXTURE3D(LPV_CHANNEL_T, source), const uint3 cellID, const LPV_CHANNEL_T valueSH)
{
    destination[cellID] = source[cellID] + valueSH;
}

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, THREAD_GROUP_SIZE)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const float3 cellID = dispatchThreadID.xyz;
    if (any(cellID >= LPV::GetGridSize()))
    {
        return;
    }

    LPV_CHANNEL_T redSH = 0;
    LPV_CHANNEL_T greenSH = 0;
    LPV_CHANNEL_T blueSH = 0;

    for (uint neighbour = 0; neighbour < DIRECTIONS_COUNT; ++neighbour)
    {
        const float3 mainDirection = directions[neighbour];
        const float3 neighbourID = cellID - mainDirection;
        if (any(neighbourID < 0) || any(neighbourID >= LPV::GetGridSize()))
        {
            continue;
        }

        const LPV_CHANNEL_T neighbourRedSH = FetchSourceSH(_SourceRedSH, neighbourID);
        const LPV_CHANNEL_T neighbourGreenSH = FetchSourceSH(_SourceGreenSH, neighbourID);
        const LPV_CHANNEL_T neighbourBlueSH = FetchSourceSH(_SourceBlueSH, neighbourID);

        if (dot(neighbourRedSH, neighbourRedSH) == 0 && dot(neighbourGreenSH, neighbourGreenSH) == 0 && dot(neighbourBlueSH, neighbourBlueSH) == 0)
        {
            continue;
        }

        const static float directFaceSubtendedSolidAngle = 0.4006696846f * INV_PI / 2;
        const static float sideFaceSubtendedSolidAngle = 0.4234413544f * INV_PI / 3;

        #if DIRECT_FACE_CONTRIBUTION
        for (uint sideFace = 0; sideFace < 4; ++sideFace)
        {
            const float3        evalDirection = GetEvalSideDirection(sideFace, mainDirection);
            const LPV_CHANNEL_T evalDirectionSH = LPVMath::DirToSH(evalDirection);
            const LPV_CHANNEL_T blockingPotentialSH = FetchBlockingPotential(neighbourID + evalDirection * 0.5);
            const float3        reprojDirection = GetReprojSideDirection(sideFace, mainDirection);
            LPV_CHANNEL_T       reprojDirectionCosineLobeSH = LPVMath::DirToCosineLobe(reprojDirection);
            reprojDirectionCosineLobeSH *= sideFaceSubtendedSolidAngle * CalculateOcclusion(blockingPotentialSH, evalDirectionSH);

            redSH += EvalPropagatedSH(neighbourRedSH, evalDirectionSH, reprojDirectionCosineLobeSH);
            greenSH += EvalPropagatedSH(neighbourGreenSH, evalDirectionSH, reprojDirectionCosineLobeSH);
            blueSH += EvalPropagatedSH(neighbourBlueSH, evalDirectionSH, reprojDirectionCosineLobeSH);
        }
        #endif

        #if SIDE_FACE_CONTRIBUTION
        {
            const LPV_CHANNEL_T mainDirectionSH = LPVMath::DirToSH(mainDirection);
            const LPV_CHANNEL_T blockingPotentialSH = FetchBlockingPotential(neighbourID + mainDirection * 0.5);
            LPV_CHANNEL_T       mainDirectionCosineLobeSH = LPVMath::DirToCosineLobe(mainDirection);
            mainDirectionCosineLobeSH *= directFaceSubtendedSolidAngle * CalculateOcclusion(blockingPotentialSH, mainDirectionSH);

            redSH += EvalPropagatedSH(neighbourRedSH, mainDirectionSH, mainDirectionCosineLobeSH);
            greenSH += EvalPropagatedSH(neighbourGreenSH, mainDirectionSH, mainDirectionCosineLobeSH);
            blueSH += EvalPropagatedSH(neighbourBlueSH, mainDirectionSH, mainDirectionCosineLobeSH);
        }
        #endif
    }

    Accumulate(_DestinationRedSH, _SourceRedSH, cellID, _Intensity * redSH);
    Accumulate(_DestinationGreenSH, _SourceGreenSH, cellID, _Intensity * greenSH);
    Accumulate(_DestinationBlueSH, _SourceBlueSH, cellID, _Intensity * blueSH);
}