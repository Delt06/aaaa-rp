#pragma kernel CS

#pragma multi_compile _ BLOCKING_POTENTIAL
#pragma multi_compile _ FIRST_STEP

// Sources:
// - https://github.com/mafian89/Light-Propagation-Volumes/blob/master/shaders/propagation.frag
// - https://ericpolman.com/2016/06/28/light-propagation-volumes/

#define SIDE_FACE_CONTRIBUTION 1
#define DIRECT_FACE_CONTRIBUTION 1

#include_with_pragmas "Packages/com.deltation.aaaa-rp/ShaderLibrary/Bindless.hlsl"

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Lighting.hlsl"

#define THREAD_GROUP_SIZE 32

ByteAddressBuffer _SourceRedSH;
ByteAddressBuffer _SourceGreenSH;
ByteAddressBuffer _SourceBlueSH;

RWByteAddressBuffer _DestinationRedSH;
RWByteAddressBuffer _DestinationGreenSH;
RWByteAddressBuffer _DestinationBlueSH;

float _OcclusionAmplification;

TYPED_TEXTURE3D(LPV_CHANNEL_T, _BlockingPotentialSH);

#define DIRECTIONS_COUNT 6
static const float3 directions[DIRECTIONS_COUNT] =
{float3(0, 0, 1), float3(0, 0, -1), float3(1, 0, 0), float3(-1, 0, 0), float3(0, 1, 0), float3(0, -1, 0)};

// right up
int2 cellSides[4] = {int2(1.0, 0.0), int2(0.0, 1.0), int2(-1.0, 0.0), int2(0.0, -1.0)};

float3 GetEvalSideDirection(int index, int3 orientation)
{
    const static float smallComponent = 0.4472135; // 1 / sqrt(5)
    const static float bigComponent = 0.894427; // 2 / sqrt(5)

    const int2   side = cellSides[index];
    const float3 tmp = float3(side.x * smallComponent, side.y * smallComponent, bigComponent);
    return float3(orientation.x * tmp.x, orientation.y * tmp.y, orientation.z * tmp.z);
}

float3 GetReprojSideDirection(int index, int3 orientation)
{
    const int2 side = cellSides[index];
    return float3(orientation.x * side.x, orientation.y * side.y, 0);
}

float CalculateOcclusion(const LPV_CHANNEL_T blockingPotentialSH, const LPV_CHANNEL_T directionSH)
{
    #if defined(BLOCKING_POTENTIAL) && !defined(FIRST_STEP)
    return 1 - saturate(_OcclusionAmplification * dot(blockingPotentialSH, directionSH));
    #else
    return 1;
    #endif
}

float4 EvalPropagatedSH(const LPV_CHANNEL_T neighborSH, const LPV_CHANNEL_T evalDirectionSH, const LPV_CHANNEL_T cosineLobeSH)
{
    return max(0, dot(neighborSH, evalDirectionSH)) * cosineLobeSH;
}

LPV_CHANNEL_T FetchSourceSH(const ByteAddressBuffer buffer, const uint3 neighbourID)
{
    const uint flatID = LPV::FlattenCellID(neighbourID);
    const uint address = LPV::FlatCellIDToBufferAddress(flatID);
    return LPVMath::UnpackChannelValue(asint(buffer.Load4(address)));
}

LPV_CHANNEL_T FetchBlockingPotential(const float3 neighbourID)
{
    const float3 uv = neighbourID / LPV::GetGridSize();
    return SAMPLE_TEXTURE3D_LOD(_BlockingPotentialSH, sampler_TrilinearClamp, uv, 0);
}

void Accumulate(RWByteAddressBuffer destination, const ByteAddressBuffer source, const uint address, const LPV_CHANNEL_T valueSH)
{
    const LPV_PACKED_CHANNEL_T sourceValue = asint(source.Load4(address));
    const LPV_PACKED_CHANNEL_T storedValue = sourceValue + LPVMath::PackChannelValue(valueSH);
    destination.Store4(address, asuint(storedValue));
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint flatCellID = dispatchThreadID.x;
    const uint gridSize = LPV::GetGridSize();
    if (flatCellID >= gridSize * gridSize * gridSize)
    {
        return;
    }

    const uint3   cellID = LPV::FlatCellIDTo3D(dispatchThreadID.x);
    LPV_CHANNEL_T redSH = 0;
    LPV_CHANNEL_T greenSH = 0;
    LPV_CHANNEL_T blueSH = 0;

    for (uint neighbour = 0; neighbour < DIRECTIONS_COUNT; ++neighbour)
    {
        const float3        mainDirection = directions[neighbour];
        const uint3         neighbourID = cellID - mainDirection;
        const LPV_CHANNEL_T neighbourRedSH = FetchSourceSH(_SourceRedSH, neighbourID);
        const LPV_CHANNEL_T neighbourGreenSH = FetchSourceSH(_SourceGreenSH, neighbourID);
        const LPV_CHANNEL_T neighbourBlueSH = FetchSourceSH(_SourceBlueSH, neighbourID);

        const static float directFaceSubtendedSolidAngle = 0.4006696846f * INV_PI / 2;
        const static float sideFaceSubtendedSolidAngle = 0.4234413544f * INV_PI / 3;

        #if DIRECT_FACE_CONTRIBUTION
        for (uint sideFace = 0; sideFace < 4; ++sideFace)
        {
            float3 evalDirection = GetEvalSideDirection(sideFace, mainDirection);
            float3 reprojDirection = GetReprojSideDirection(sideFace, mainDirection);

            const LPV_CHANNEL_T reprojDirectionCosineLobeSH = LPVMath::DirToCosineLobe(reprojDirection);
            const LPV_CHANNEL_T evalDirectionSH = LPVMath::DirToSH(evalDirection);
            const LPV_CHANNEL_T blockingPotentialSH = FetchBlockingPotential(neighbourID + evalDirection * 0.5);
            const float         occlusion = CalculateOcclusion(blockingPotentialSH, evalDirectionSH);

            redSH += occlusion * sideFaceSubtendedSolidAngle * EvalPropagatedSH(neighbourRedSH, evalDirectionSH, reprojDirectionCosineLobeSH);
            greenSH += occlusion * sideFaceSubtendedSolidAngle * EvalPropagatedSH(neighbourGreenSH, evalDirectionSH, reprojDirectionCosineLobeSH);
            blueSH += occlusion * sideFaceSubtendedSolidAngle * EvalPropagatedSH(neighbourBlueSH, evalDirectionSH, reprojDirectionCosineLobeSH);
        }
        #endif

        #if SIDE_FACE_CONTRIBUTION
        {
            const LPV_CHANNEL_T mainDirectionCosineLobeSH = LPVMath::DirToCosineLobe(mainDirection);
            const LPV_CHANNEL_T mainDirectionSH = LPVMath::DirToSH(mainDirection);
            const LPV_CHANNEL_T blockingPotentialSH = FetchBlockingPotential(neighbourID + mainDirection * 0.5);
            const float         occlusion = CalculateOcclusion(blockingPotentialSH, mainDirectionSH);

            redSH += occlusion * directFaceSubtendedSolidAngle * EvalPropagatedSH(neighbourRedSH, mainDirectionSH, mainDirectionCosineLobeSH);
            greenSH += occlusion * directFaceSubtendedSolidAngle * EvalPropagatedSH(neighbourGreenSH, mainDirectionSH, mainDirectionCosineLobeSH);
            blueSH += occlusion * directFaceSubtendedSolidAngle * EvalPropagatedSH(neighbourBlueSH, mainDirectionSH, mainDirectionCosineLobeSH);
        }
        #endif
    }

    const uint workingAddress = LPV::FlatCellIDToBufferAddress(flatCellID);
    Accumulate(_DestinationRedSH, _SourceRedSH, workingAddress, redSH);
    Accumulate(_DestinationGreenSH, _SourceGreenSH, workingAddress, greenSH);
    Accumulate(_DestinationBlueSH, _SourceBlueSH, workingAddress, blueSH);
}