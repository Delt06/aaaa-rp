#pragma kernel CS


#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Depth.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/CameraDepth.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/GBuffer.hlsl"
#include "Packages/com.deltation.aaaa-rp/Runtime/Passes/GlobalIllumination/SSR/SSRComputeShaders.cs.hlsl"

#define THREAD_GROUP_SIZE TRACE_THREAD_GROUP_SIZE

float4x4 _SSR_ViewProjMatrix;
float4x4 _SSR_InvViewProjMatrix;
float4   _SSR_CameraPosition;
float4   _SSR_ScreenSize;

RWTexture2D<float4> _Result;

float2 PixelUVToNDC(const float2 pixelUV)
{
    float2 result = pixelUV;
    result = result * 2 - 1;
    #ifdef UNITY_UV_STARTS_AT_TOP
    result.y *= -1;
    #endif
    return result;
}

float2 NDCToPixelUV(const float2 ndc)
{
    float2 result = ndc;
    #ifdef UNITY_UV_STARTS_AT_TOP
    result.y *= -1;
    #endif
    result = result * 0.5 + 0.5;
    return result;
}

#define MAX_REFLECTION_RAY_MARCH_STEP 0.01f
#define NUM_RAY_MARCH_SAMPLES 256
#define NUM_BINARY_SEARCH_SAMPLES 16

float3 BinarySearch(const float3 raySampleSS, float3 prevRaySampleSS)
{
    float3 raySampleMinSS = prevRaySampleSS;
    float3 raySampleMaxSS = raySampleSS;
    float3 raySampleMidSS;
    for (int i = 0; i < NUM_BINARY_SEARCH_SAMPLES; i++)
    {
        raySampleMidSS = lerp(raySampleMinSS, raySampleMaxSS, 0.5);
        const float zBufferValue = SampleDeviceDepth(raySampleMidSS.xy).r;

        if (GREATER_DEPTH(raySampleMidSS.z, zBufferValue))
        {
            raySampleMaxSS = raySampleMidSS;
        }
        else
        {
            raySampleMinSS = raySampleMidSS;
        }
    }

    return raySampleMidSS;
}

#define ReflectionRayMarchStep MAX_REFLECTION_RAY_MARCH_STEP

bool GetReflection(
    float3     reflectionSS,
    float3     positionSS,
    out float2 result)
{
    float3 prevRaySampleSS = positionSS;
    result = 0;

    for (int rayStepIndex = 1; rayStepIndex <= NUM_RAY_MARCH_SAMPLES; rayStepIndex++)
    {
        float3      raySampleSS = (rayStepIndex * ReflectionRayMarchStep) * reflectionSS + positionSS;
        const float zBufferValue = SampleDeviceDepth(raySampleSS.xy);

        if (zBufferValue == UNITY_RAW_FAR_CLIP_VALUE)
        {
            // Hit skybox
            return false;
        }

        if (any(raySampleSS.xy < 0) || any(raySampleSS.xy > 1))
        {
            // Went past screen edges.
            return false;
        }

        if (GREATER_DEPTH(raySampleSS.z, zBufferValue))
        {
            // Hit something
            raySampleSS = BinarySearch(raySampleSS, prevRaySampleSS);
            result = raySampleSS.xy;
            return true;
        }
    }

    // Could not converge
    return false;
}

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint2 pixelCoords = dispatchThreadID.xy;

    UNITY_BRANCH
    if (all((float2)pixelCoords < _SSR_ScreenSize.xy))
    {
        const float2 pixelUV = pixelCoords.xy * _SSR_ScreenSize.zw;
        const float2 positionNDC = PixelUVToNDC(pixelUV);
        const float  deviceZ = LoadDeviceDepth(pixelCoords);

        float4 positionWS = mul(_SSR_InvViewProjMatrix, float4(positionNDC, deviceZ, 1));
        positionWS /= positionWS.w;

        const float3 eyeWS = normalize(positionWS.xyz - _SSR_CameraPosition.xyz);
        const float3 normalWS = UnpackGBufferNormal(LOAD_TEXTURE2D(_GBuffer_Normals, pixelCoords).xy);

        const float4 positionSS = float4(pixelUV, deviceZ, 1.0f);
        const float3 reflectionWS = reflect(eyeWS, normalWS);

        // This will check the direction of the reflection vector with the view direction,
        // and if they are pointing in the same direction, it will drown out those reflections 
        // since we are limited to pixels visible on screen. Attenuate reflections for angles between 
        // 60 degrees and 75 degrees, and drop all contribution beyond the (-60,60)  degree range
        float cameraFacingReflectionAttenuation = 1 - smoothstep(0.25, 0.5, dot(-eyeWS, reflectionWS));

        // Reject if the reflection vector is pointing back at the viewer.
        UNITY_BRANCH
        if (cameraFacingReflectionAttenuation <= 0)
        {
            _Result[pixelCoords] = 0;
        }
        else
        {
            const float3 reflectionPointWS = 10.0f * reflectionWS + positionWS.xyz;

            float4 reflectionPointSS = mul(_SSR_ViewProjMatrix, float4(reflectionPointWS, 1));
            reflectionPointSS /= reflectionPointSS.w;
            reflectionPointSS.xy = NDCToPixelUV(reflectionPointSS.xy);

            const float3 reflectionSS = normalize(reflectionPointSS.xyz - positionSS.xyz);

            float2     reflectionUV;
            const bool hit = GetReflection(reflectionSS, positionSS.xyz, reflectionUV);
            float      attenuation = cameraFacingReflectionAttenuation;

            if (hit)
            {
                // This will check the direction of the normal of the reflection sample with the
                // direction of the reflection vector, and if they are pointing in the same direction,
                // it will drown out those reflections since backward facing pixels are not available 
                // for screen space reflection. Attenuate reflections for angles between 90 degrees 
                // and 100 degrees, and drop all contribution beyond the (-100,100)  degree range
                const float2 packedGBufferNormals = SAMPLE_TEXTURE2D_LOD(_GBuffer_Normals, sampler_LinearClamp, reflectionUV.xy, 0).xy;
                const float3 reflectionNormalWS = UnpackGBufferNormal(packedGBufferNormals);
                const float  directionBasedAttenuation = smoothstep(-0.17, 0.0, dot(reflectionNormalWS.xyz, -reflectionWS));
                attenuation *= directionBasedAttenuation;

                // Attenuate samples near screen edges.
                const float  uvEdge = 0.025f;
                const float2 uvSamplingAttenuation = smoothstep(0.0, uvEdge, reflectionUV) * (1 - smoothstep(1 - uvEdge, 1, reflectionUV));
                attenuation *= uvSamplingAttenuation.x * uvSamplingAttenuation.y;
            }

            _Result[pixelCoords] = hit ? float4(reflectionUV, 1, attenuation) : float4(0, 0, 0, 0);
        }
    }
}