#pragma kernel CS

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE MESHLET_LIST_BUILD_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Math.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshLODNodes.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/DataStructures/MPMCQueue.hlsl"

float4   _CameraFrustumPlanes[PLANES_IN_FRUSTUM];
float4x4 _CameraViewProjection;

uint _ForcedMeshLODNodeDepth;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

globallycoherent RWByteAddressBuffer _VisitedNodes;
globallycoherent RWByteAddressBuffer _WorkQueueSlots;
globallycoherent RWByteAddressBuffer _WorkQueueHeadTail;
uint                                 _WorkQueueCapacity;

groupshared uint g_CurrentTopLODNode;

struct WorkNode
{
    uint InstanceID;
    uint MeshLODNodeIndex;
};

#define VISITED_NODES_MASK_BITS 32

bool TryVisitNode(const uint nodeIndex)
{
    const uint maskIndex = nodeIndex / VISITED_NODES_MASK_BITS;
    const uint bitIndex = nodeIndex % VISITED_NODES_MASK_BITS;
    const uint thisMask = 1u << bitIndex;

    uint oldMask;
    _VisitedNodes.InterlockedOr(maskIndex * 4, thisMask, oldMask);
    return (oldMask & thisMask) == 0;
}

void EnqueueWorkNode(MPMCQueue queue, const WorkNode workNode)
{
    queue.Enqueue(uint3(workNode.InstanceID, workNode.MeshLODNodeIndex, 0));
}

bool TryDequeueWorkNode(MPMCQueue queue, out WorkNode workNode)
{
    bool result;
    workNode = (WorkNode)0;

    MPMC_QUEUE_VALUE_T value;

    UNITY_BRANCH
    if (queue.TryDequeue(value))
    {
        workNode.InstanceID = value.x;
        workNode.MeshLODNodeIndex = value.y;
        result = true;
    }
    else
    {
        result = false;
    }

    return result;
}

void PushMeshletRenderRequests(const uint instanceID, const AAAAMeshLODNode meshLODNode)
{
    uint meshletWriteOffset;
    _DestinationMeshletsCounter.InterlockedAdd(0, meshLODNode.MeshletCount, meshletWriteOffset);

    for (uint i = 0; i < meshLODNode.MeshletCount; ++i)
    {
        AAAAMeshletRenderRequest meshletRenderRequest;
        meshletRenderRequest.InstanceID = instanceID;
        meshletRenderRequest.MeshletID = meshLODNode.MeshletStartIndex + i;

        StoreMeshletRenderRequest(_DestinationMeshlets, meshletWriteOffset + i, meshletRenderRequest);
    }
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 groupThreadID : SV_GroupThreadID, const uint3 groupID : SV_GroupID)
{
    const uint instanceID = groupID.x;
    if (instanceID >= _InstanceCount)
    {
        return;
    }

    const AAAAInstanceData instanceData = PullInstanceData(instanceID);

    const AABB   aabbOS = AABB::Create(instanceData.AABBMin.xyz, instanceData.AABBMax.xyz);
    const AABB   aabbWS = TransformAABB(aabbOS, instanceData.ObjectToWorldMatrix);
    const float4 instanceBoundingSphere = AABBToBoundingSphere(aabbWS);

    UNITY_BRANCH
    if (!FrustumVsSphereCulling(_CameraFrustumPlanes, instanceBoundingSphere))
    {
        return;
    }

    const uint localThreadIndex = groupThreadID.x;

    if (localThreadIndex == 0)
    {
        g_CurrentTopLODNode = 0;
    }

    GroupMemoryBarrierWithGroupSync();

    MPMCQueue workQueue = MPMCQueue::Construct(_WorkQueueSlots, _WorkQueueHeadTail, _WorkQueueCapacity);

    const float2 instanceSizeSS = AABBScreenSize(aabbWS, _CameraViewProjection);

    bool stopProcessing = false;

    UNITY_LOOP
    while (!stopProcessing)
    {
        uint topLODOffset = UINT_MAX;

        // Check if there are top level nodes to process
        if (g_CurrentTopLODNode <= instanceData.TopMeshLODCount - 1)
        {
            // Try to take a node 
            InterlockedAdd(g_CurrentTopLODNode, 1, topLODOffset);
            if (topLODOffset >= instanceData.TopMeshLODCount)
            {
                topLODOffset = UINT_MAX;
            }
        }

        UNITY_LOOP
        while (true)
        {
            WorkNode parentWorkNode;

            UNITY_BRANCH
            if (topLODOffset != UINT_MAX)
            {
                // Process the take top level node directly, without pushing to the queue
                parentWorkNode.InstanceID = instanceID;
                parentWorkNode.MeshLODNodeIndex = instanceData.TopMeshLODStartIndex + topLODOffset;
                topLODOffset = UINT_MAX;
            }
            else if (!TryDequeueWorkNode(workQueue, parentWorkNode))
            {
                if (workQueue.IsEmpty())
                {
                    stopProcessing = true;
                }

                break;
            }

            if (!TryVisitNode(parentWorkNode.MeshLODNodeIndex))
            {
                continue;
            }

            const AAAAMeshLODNode parentNode = PullMeshLODNode(parentWorkNode.MeshLODNodeIndex);

            UNITY_BRANCH
            if (parentNode.IsLeaf || parentNode.LevelIndex == _ForcedMeshLODNodeDepth)
            {
                PushMeshletRenderRequests(parentWorkNode.InstanceID, parentNode);
            }
            else
            {
                UNITY_LOOP
                for (uint i = 0; i < (uint)CHILDREN_COUNT; ++i)
                {
                    const uint childNodeIndex = parentNode.ChildrenNodeIndices[i];
                    if (childNodeIndex == (uint)INVALID_CHILD_INDEX)
                    {
                        break;
                    }

                    WorkNode childWorkNode;
                    childWorkNode.InstanceID = parentWorkNode.InstanceID;
                    childWorkNode.MeshLODNodeIndex = childNodeIndex;
                    EnqueueWorkNode(workQueue, childWorkNode);
                }
            }
        }
    }
}