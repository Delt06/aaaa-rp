#pragma kernel CS

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE MESHLET_LIST_BUILD_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshLODNodes.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshletListBuild.hlsl"

uint _ForcedMeshLODNodeDepth;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

ByteAddressBuffer _SourceWorkQueue;
ByteAddressBuffer _SourceWorkQueueSize;

RWByteAddressBuffer _DestinationWorkQueue;
RWByteAddressBuffer _DestinationWorkQueueSize;

RWByteAddressBuffer _VisitedMask;

bool TryVisitNode(const WorkNode workNode, const uint localNodeIndex)
{
    const uint maskIndex = localNodeIndex / VISITED_MASK_BITS;
    const uint bitIndex = localNodeIndex % VISITED_MASK_BITS;

    const uint thisBitMask = 1u << bitIndex;
    uint       oldMask;
    _VisitedMask.InterlockedOr((maskIndex + workNode.VisitedMaskOffset) * 4, thisBitMask, oldMask);
    return (oldMask & thisBitMask) == 0;
}

void PushMeshletRenderRequests(const uint instanceID, const AAAAMeshLODNode meshLODNode)
{
    uint meshletWriteOffset;
    _DestinationMeshletsCounter.InterlockedAdd(0, meshLODNode.MeshletCount, meshletWriteOffset);

    for (uint i = 0; i < meshLODNode.MeshletCount; ++i)
    {
        AAAAMeshletRenderRequest meshletRenderRequest;
        meshletRenderRequest.InstanceID = instanceID;
        meshletRenderRequest.MeshletID = meshLODNode.MeshletStartIndex + i;

        StoreMeshletRenderRequest(_DestinationMeshlets, meshletWriteOffset + i, meshletRenderRequest);
    }
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint sourceItemIndex = dispatchThreadID.x;
    if (sourceItemIndex >= _SourceWorkQueueSize.Load(0))
    {
        return;
    }

    const WorkNode         parentWorkNode = LoadWorkNode(_SourceWorkQueue, sourceItemIndex);
    const AAAAMeshLODNode  parentMeshLODNode = PullMeshLODNode(parentWorkNode.MeshLODNodeIndex);
    const AAAAInstanceData instanceData = PullInstanceData(parentWorkNode.InstanceID);

    UNITY_BRANCH
    if (parentMeshLODNode.IsLeaf || parentMeshLODNode.LevelIndex == _ForcedMeshLODNodeDepth)
    {
        PushMeshletRenderRequests(parentWorkNode.InstanceID, parentMeshLODNode);
    }
    else
    {
        UNITY_LOOP
        for (uint childIndex = 0; childIndex < (uint)CHILDREN_COUNT; ++childIndex)
        {
            const uint childNodeIndex = parentMeshLODNode.ChildrenNodeIndices[childIndex];
            if (childNodeIndex == (uint)INVALID_CHILD_INDEX)
            {
                break;
            }

            WorkNode childWorkNode;
            childWorkNode.InstanceID = parentWorkNode.InstanceID;
            childWorkNode.MeshLODNodeIndex = childNodeIndex;
            childWorkNode.VisitedMaskOffset = parentWorkNode.VisitedMaskOffset;

            if (!TryVisitNode(childWorkNode, childNodeIndex - instanceData.TopMeshLODStartIndex))
            {
                continue;
            }

            uint offset;
            _DestinationWorkQueueSize.InterlockedAdd(0, 1, offset);
            StoreWorkNode(_DestinationWorkQueue, offset, childWorkNode);
        }
    }
}