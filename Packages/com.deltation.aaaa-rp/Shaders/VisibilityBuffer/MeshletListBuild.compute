#pragma kernel CS

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE MESHLET_LIST_BUILD_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Math.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshLODNodes.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshletListBuild.hlsl"

uint  _ForcedMeshLODNodeDepth;
float _MeshLODErrorThreshold;

float4x4 _CameraViewProjection;
float4   _CameraPosition;
float4   _CameraUp;
float4   _CameraRight;
float2   _ScreenSizePixels;

StructuredBuffer<AAAAMeshletListBuildJob> _Jobs;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

float2 GetNormalizedScreenCoordinates(const float4x4 mvpMatrix, const float3 positionWS)
{
    float4 centerCS = mul(mvpMatrix, float4(positionWS, 1.0f));
    centerCS.xy /= centerCS.w;
    centerCS.xy = centerCS.xy * 0.5f + 0.5f;
    return centerCS.xy;
}

float GetScreenBoundRadiusSq(const float4x4 vpMatrix, const float4 boundsWS)
{
    const float2 p0 = GetNormalizedScreenCoordinates(vpMatrix, boundsWS.xyz);
    const float2 p1 = GetNormalizedScreenCoordinates(vpMatrix, boundsWS.xyz + _CameraUp.xyz * boundsWS.w);
    const float2 p2 = GetNormalizedScreenCoordinates(vpMatrix, boundsWS.xyz + _CameraRight.xyz * boundsWS.w);

    const float2 v0 = (p1 - p0) * _ScreenSizePixels;
    const float2 v1 = (p2 - p0) * _ScreenSizePixels;
    return max(dot(v0, v0), dot(v1, v1));
}

void PushMeshletRenderRequests(const uint instanceID, const AAAAMeshLODNode meshLODNode)
{
    uint meshletWriteOffset;
    _DestinationMeshletsCounter.InterlockedAdd(0, meshLODNode.MeshletCount, meshletWriteOffset);

    for (uint i = 0; i < meshLODNode.MeshletCount; ++i)
    {
        AAAAMeshletRenderRequest meshletRenderRequest;
        meshletRenderRequest.InstanceID = instanceID;
        meshletRenderRequest.MeshletID = meshLODNode.MeshletStartIndex + i;

        StoreMeshletRenderRequest(_DestinationMeshlets, meshletWriteOffset + i, meshletRenderRequest);
    }
}

bool ShouldPushMeshletRenderRequests(const AAAAMeshLODNode meshLODNode, const AAAAInstanceData instanceData, const float distanceToViewSq)
{
    bool result;

    UNITY_BRANCH
    if (_ForcedMeshLODNodeDepth != UINT_MAX)
    {
        const bool isLeaf = meshLODNode.LevelIndex == instanceData.MeshLODLevelCount - 1;
        result = meshLODNode.LevelIndex == _ForcedMeshLODNodeDepth || meshLODNode.LevelIndex < _ForcedMeshLODNodeDepth && isLeaf;
    }
    else
    {
        const float4 boundsWS = TransformBoundingSphere(meshLODNode.Bounds, instanceData.ObjectToWorldMatrix);
        const float4 parentBoundsWS = TransformBoundingSphere(meshLODNode.ParentBounds, instanceData.ObjectToWorldMatrix);
        const float  error = meshLODNode.Error * GetScreenBoundRadiusSq(_CameraViewProjection, boundsWS);
        const float  parentError = meshLODNode.ParentError >= 0
                                      ? meshLODNode.ParentError * GetScreenBoundRadiusSq(_CameraViewProjection, parentBoundsWS)
                                      : FLT_INF;
        const float threshold = _MeshLODErrorThreshold * distanceToViewSq * instanceData.LODErrorScale;
        result = parentError > threshold && error <= threshold;
    }

    return result;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 groupThreadID : SV_GroupThreadID, const uint3 groupID : SV_GroupID)
{
    const AAAAMeshletListBuildJob job = _Jobs[groupID.x];
    const AAAAInstanceData        instanceData = PullInstanceData(job.InstanceID);

    const float3 instanceBoundsCenter = (instanceData.AABBMin.xyz + instanceData.AABBMax.xyz) * 0.5f;
    const float  distanceToViewSq = Length2(_CameraPosition.xyz - instanceBoundsCenter);

    const uint from = instanceData.TopMeshLODStartIndex + job.MeshLODNodeOffset;
    const uint to = from + job.MeshLODNodeCount;

    for (uint nodeIndex = from + groupThreadID.x; nodeIndex < to; nodeIndex += THREAD_GROUP_SIZE)
    {
        const AAAAMeshLODNode meshLODNode = PullMeshLODNode(nodeIndex);

        if (ShouldPushMeshletRenderRequests(meshLODNode, instanceData, distanceToViewSq))
        {
            PushMeshletRenderRequests(job.InstanceID, meshLODNode);
        }
    }
}