#pragma kernel CS

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE MESHLET_LIST_BUILD_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshLODNodes.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshletListBuild.hlsl"

uint _ForcedMeshLODNodeDepth;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

ByteAddressBuffer _SourceWorkQueue;
ByteAddressBuffer _SourceWorkQueueSize;

RWByteAddressBuffer _DestinationWorkQueue;
RWByteAddressBuffer _DestinationWorkQueueSize;

RWByteAddressBuffer _VisitedMask;

groupshared uint3 g_BatchedWorkNodes[THREAD_GROUP_SIZE * CHILDREN_COUNT];
groupshared uint  g_BatchedWorkNodesCount;

bool TryVisitNode(const WorkNode workNode, const uint localNodeIndex)
{
    const uint maskIndex = localNodeIndex / VISITED_MASK_BITS;
    const uint bitIndex = localNodeIndex % VISITED_MASK_BITS;

    const uint thisBitMask = 1u << bitIndex;
    uint       oldMask;
    _VisitedMask.InterlockedOr((maskIndex + workNode.VisitedMaskOffset) * 4, thisBitMask, oldMask);
    return (oldMask & thisBitMask) == 0;
}

void PushMeshletRenderRequests(const uint instanceID, const AAAAMeshLODNode meshLODNode)
{
    uint meshletWriteOffset;
    _DestinationMeshletsCounter.InterlockedAdd(0, meshLODNode.MeshletCount, meshletWriteOffset);

    for (uint i = 0; i < meshLODNode.MeshletCount; ++i)
    {
        AAAAMeshletRenderRequest meshletRenderRequest;
        meshletRenderRequest.InstanceID = instanceID;
        meshletRenderRequest.MeshletID = meshLODNode.MeshletStartIndex + i;

        StoreMeshletRenderRequest(_DestinationMeshlets, meshletWriteOffset + i, meshletRenderRequest);
    }
}

bool ShouldPushMeshletRenderRequests(const AAAAMeshLODNode meshLODNode)
{
    return meshLODNode.IsLeaf || meshLODNode.LevelIndex == _ForcedMeshLODNodeDepth;
}

void ProcessChildrenNodes(const WorkNode parentWorkNode, const AAAAMeshLODNode       parentMeshLODNode, const AAAAInstanceData instanceData,
                          out uint3      childrenWorkNodes[CHILDREN_COUNT], out uint childrenWorkNodeCount
)
{
    childrenWorkNodeCount = 0;

    UNITY_LOOP
    for (uint childIndex = 0; childIndex < (uint)CHILDREN_COUNT; ++childIndex)
    {
        const uint childNodeIndex = parentMeshLODNode.ChildrenNodeIndices[childIndex];
        if (childNodeIndex == (uint)INVALID_CHILD_INDEX)
        {
            break;
        }

        WorkNode childWorkNode;
        childWorkNode.InstanceID = parentWorkNode.InstanceID;
        childWorkNode.MeshLODNodeIndex = childNodeIndex;
        childWorkNode.VisitedMaskOffset = parentWorkNode.VisitedMaskOffset;

        if (!TryVisitNode(childWorkNode, childNodeIndex - instanceData.TopMeshLODStartIndex))
        {
            continue;
        }

        childrenWorkNodes[childrenWorkNodeCount++] = PackWorkNode(childWorkNode);
    }
}

void ProcessWorkFromSourceToBatched(const uint sourceItemIndex)
{
    UNITY_BRANCH
    if (sourceItemIndex < _SourceWorkQueueSize.Load(0))
    {
        const WorkNode         parentWorkNode = LoadWorkNode(_SourceWorkQueue, sourceItemIndex);
        const AAAAMeshLODNode  parentMeshLODNode = PullMeshLODNode(parentWorkNode.MeshLODNodeIndex);
        const AAAAInstanceData instanceData = PullInstanceData(parentWorkNode.InstanceID);

        UNITY_BRANCH
        if (ShouldPushMeshletRenderRequests(parentMeshLODNode))
        {
            PushMeshletRenderRequests(parentWorkNode.InstanceID, parentMeshLODNode);
        }
        else
        {
            uint3 childrenWorkNodes[CHILDREN_COUNT];
            uint  childrenWorkNodeCount;
            ProcessChildrenNodes(parentWorkNode, parentMeshLODNode, instanceData, childrenWorkNodes, childrenWorkNodeCount);

            uint offset;
            InterlockedAdd(g_BatchedWorkNodesCount, childrenWorkNodeCount, offset);

            for (uint childIndex = 0; childIndex < childrenWorkNodeCount; ++childIndex)
            {
                g_BatchedWorkNodes[offset + childIndex] = childrenWorkNodes[childIndex];
            }
        }
    }
}

void ProcessWorkFromBatchedToDestination(const uint sourceItemIndex)
{
    const WorkNode         parentWorkNode = UnpackWorkNode(g_BatchedWorkNodes[sourceItemIndex]);
    const AAAAMeshLODNode  parentMeshLODNode = PullMeshLODNode(parentWorkNode.MeshLODNodeIndex);
    const AAAAInstanceData instanceData = PullInstanceData(parentWorkNode.InstanceID);

    UNITY_BRANCH
    if (ShouldPushMeshletRenderRequests(parentMeshLODNode))
    {
        PushMeshletRenderRequests(parentWorkNode.InstanceID, parentMeshLODNode);
    }
    else
    {
        uint3 childrenWorkNodes[CHILDREN_COUNT];
        uint  childrenWorkNodeCount;
        ProcessChildrenNodes(parentWorkNode, parentMeshLODNode, instanceData, childrenWorkNodes, childrenWorkNodeCount);

        uint offset;
        _DestinationWorkQueueSize.InterlockedAdd(0, childrenWorkNodeCount, offset);

        for (uint childIndex = 0; childIndex < childrenWorkNodeCount; ++childIndex)
        {
            StoreWorkNode(_DestinationWorkQueue, offset + childIndex, childrenWorkNodes[childIndex]);
        }
    }
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID, const uint3 groupThreadID : SV_GroupThreadID)
{
    if (groupThreadID.x == 0)
    {
        g_BatchedWorkNodesCount = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    ProcessWorkFromSourceToBatched(dispatchThreadID.x);
    GroupMemoryBarrierWithGroupSync();

    UNITY_BRANCH
    if (g_BatchedWorkNodesCount > 0)
    {
        UNITY_LOOP
        for (uint i = groupThreadID.x; i < g_BatchedWorkNodesCount; i += THREAD_GROUP_SIZE)
        {
            ProcessWorkFromBatchedToDestination(i);
        }
    }
}