#pragma kernel CS

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE MESHLET_LIST_BUILD_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshLODNodes.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshletListBuild.hlsl"

uint _ForcedMeshLODNodeDepth;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

ByteAddressBuffer _SourceWorkQueue;
ByteAddressBuffer _SourceWorkQueueSize;

RWByteAddressBuffer _DestinationWorkQueue;
RWByteAddressBuffer _DestinationWorkQueueSize;

RWByteAddressBuffer _VisitedMask;

groupshared uint3 g_BatchedWorkNodes[THREAD_GROUP_SIZE * CHILDREN_COUNT];
groupshared uint  g_BatchedWorkNodesCount;
groupshared uint  g_BatchedWorkNodesWriteOffset;

bool TryVisitNode(const WorkNode workNode, const uint localNodeIndex)
{
    const uint maskIndex = localNodeIndex / VISITED_MASK_BITS;
    const uint bitIndex = localNodeIndex % VISITED_MASK_BITS;

    const uint thisBitMask = 1u << bitIndex;
    uint       oldMask;
    _VisitedMask.InterlockedOr((maskIndex + workNode.VisitedMaskOffset) * 4, thisBitMask, oldMask);
    return (oldMask & thisBitMask) == 0;
}

void PushMeshletRenderRequests(const uint instanceID, const AAAAMeshLODNode meshLODNode)
{
    uint meshletWriteOffset;
    _DestinationMeshletsCounter.InterlockedAdd(0, meshLODNode.MeshletCount, meshletWriteOffset);

    for (uint i = 0; i < meshLODNode.MeshletCount; ++i)
    {
        AAAAMeshletRenderRequest meshletRenderRequest;
        meshletRenderRequest.InstanceID = instanceID;
        meshletRenderRequest.MeshletID = meshLODNode.MeshletStartIndex + i;

        StoreMeshletRenderRequest(_DestinationMeshlets, meshletWriteOffset + i, meshletRenderRequest);
    }
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID, const uint3 groupThreadID : SV_GroupThreadID)
{
    if (groupThreadID.x == 0)
    {
        g_BatchedWorkNodesCount = 0;
    }

    GroupMemoryBarrierWithGroupSync();

    const uint sourceItemIndex = dispatchThreadID.x;
    UNITY_BRANCH
    if (sourceItemIndex < _SourceWorkQueueSize.Load(0))
    {
        const WorkNode         parentWorkNode = LoadWorkNode(_SourceWorkQueue, sourceItemIndex);
        const AAAAMeshLODNode  parentMeshLODNode = PullMeshLODNode(parentWorkNode.MeshLODNodeIndex);
        const AAAAInstanceData instanceData = PullInstanceData(parentWorkNode.InstanceID);

        UNITY_BRANCH
        if (parentMeshLODNode.IsLeaf || parentMeshLODNode.LevelIndex == _ForcedMeshLODNodeDepth)
        {
            PushMeshletRenderRequests(parentWorkNode.InstanceID, parentMeshLODNode);
        }
        else
        {
            UNITY_LOOP
            for (uint childIndex = 0; childIndex < (uint)CHILDREN_COUNT; ++childIndex)
            {
                const uint childNodeIndex = parentMeshLODNode.ChildrenNodeIndices[childIndex];
                if (childNodeIndex == (uint)INVALID_CHILD_INDEX)
                {
                    break;
                }

                WorkNode childWorkNode;
                childWorkNode.InstanceID = parentWorkNode.InstanceID;
                childWorkNode.MeshLODNodeIndex = childNodeIndex;
                childWorkNode.VisitedMaskOffset = parentWorkNode.VisitedMaskOffset;

                if (!TryVisitNode(childWorkNode, childNodeIndex - instanceData.TopMeshLODStartIndex))
                {
                    continue;
                }

                uint offset;
                InterlockedAdd(g_BatchedWorkNodesCount, 1, offset);
                g_BatchedWorkNodes[offset] = PackWorkNode(childWorkNode);
            }
        }
    }

    GroupMemoryBarrierWithGroupSync();

    if (g_BatchedWorkNodesCount > 0)
    {
        if (groupThreadID.x == 0)
        {
            _DestinationWorkQueueSize.InterlockedAdd(0, g_BatchedWorkNodesCount, g_BatchedWorkNodesWriteOffset);
        }

        GroupMemoryBarrierWithGroupSync();

        for (uint i = groupThreadID.x; i < g_BatchedWorkNodesCount; i += THREAD_GROUP_SIZE)
        {
            StoreWorkNode(_DestinationWorkQueue, g_BatchedWorkNodesWriteOffset + i, g_BatchedWorkNodes[i]);
        }
    }
}