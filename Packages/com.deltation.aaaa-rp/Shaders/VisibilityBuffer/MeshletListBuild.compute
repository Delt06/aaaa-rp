#pragma kernel CS

#pragma enable_d3d11_debug_symbols

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE MESHLET_LIST_BUILD_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshLODNodes.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshletListBuild.hlsl"

uint  _ForcedMeshLODNodeDepth;
float _MeshLODTargetErrorBias;

StructuredBuffer<AAAAMeshletListBuildJob> _Jobs;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

void PushMeshletRenderRequests(const uint instanceID, const AAAAMeshLODNode meshLODNode)
{
    uint meshletWriteOffset;
    _DestinationMeshletsCounter.InterlockedAdd(0, meshLODNode.MeshletCount, meshletWriteOffset);

    for (uint i = 0; i < meshLODNode.MeshletCount; ++i)
    {
        AAAAMeshletRenderRequest meshletRenderRequest;
        meshletRenderRequest.InstanceID = instanceID;
        meshletRenderRequest.MeshletID = meshLODNode.MeshletStartIndex + i;

        StoreMeshletRenderRequest(_DestinationMeshlets, meshletWriteOffset + i, meshletRenderRequest);
    }
}

bool ShouldPushMeshletRenderRequests(const AAAAMeshLODNode meshLODNode)
{
    bool result;

    if (_ForcedMeshLODNodeDepth != UINT_MAX)
    {
        result = meshLODNode.LevelIndex == _ForcedMeshLODNodeDepth || meshLODNode.ChildrenCount == 0 && meshLODNode.LevelIndex < _ForcedMeshLODNodeDepth;
    }
    else
    {
        result = meshLODNode.ParentError > _MeshLODTargetErrorBias && meshLODNode.Error <= _MeshLODTargetErrorBias;
    }

    return result;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 groupThreadID : SV_GroupThreadID, const uint3 groupID : SV_GroupID)
{
    const AAAAMeshletListBuildJob job = _Jobs[groupID.x];
    const AAAAInstanceData        instanceData = PullInstanceData(job.InstanceID);

    const uint from = instanceData.TopMeshLODStartIndex + job.MeshLODNodeOffset;
    const uint to = from + job.MeshLODNodeCount;

    for (uint nodeIndex = from + groupThreadID.x; nodeIndex < to; nodeIndex += THREAD_GROUP_SIZE)
    {
        const AAAAMeshLODNode meshLODNode = PullMeshLODNode(nodeIndex);

        if (ShouldPushMeshletRenderRequests(meshLODNode))
        {
            PushMeshletRenderRequests(job.InstanceID, meshLODNode);
        }
    }
}