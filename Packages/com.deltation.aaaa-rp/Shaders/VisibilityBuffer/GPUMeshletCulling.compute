#pragma kernel CS

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE GPUMESHLET_CULLING_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Math.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"

float4 _CameraPosition;
float4 _CameraFrustumPlanes[PLANES_IN_FRUSTUM];

ByteAddressBuffer _SourceMeshletsCounter;
ByteAddressBuffer _SourceMeshlets;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

bool ConeCulling(const AAAAInstanceData instanceData, const AAAAMeshlet meshlet)
{
    const float3 coneApexWS = TransformObjectToWorld(meshlet.ConeApexCutoff.xyz, instanceData.ObjectToWorldMatrix);
    const float3 coneAxisWS = TransformObjectToWorldNormal(meshlet.ConeAxis.xyz, instanceData.WorldToObjectMatrix);
    const float  dotResult = dot(normalize(coneApexWS - _CameraPosition.xyz), coneAxisWS);
    // using !>= handles the case when the meshlet's coneAxis is (0, 0, 0)
    // dotResult stores NaN in this case
    return !(dotResult >= meshlet.ConeApexCutoff.w);
}

bool Culling(const AAAAInstanceData instanceData, const AAAAMeshlet meshletData)
{
    const float4 boundingSphere = TransformBoundingSphere(meshletData.BoundingSphere, instanceData.ObjectToWorldMatrix);
    return FrustumVsSphereCulling(_CameraFrustumPlanes, boundingSphere) && ConeCulling(instanceData, meshletData);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint meshletsCount = _SourceMeshletsCounter.Load(0);
    const uint sourceMeshletID = dispatchThreadID.x;

    UNITY_BRANCH
    if (sourceMeshletID >= meshletsCount)
    {
        return;
    }

    const AAAAMeshletRenderRequest meshletRenderRequest = PullMeshletRenderRequest(_SourceMeshlets, sourceMeshletID);
    const AAAAInstanceData         instanceData = PullInstanceData(meshletRenderRequest.InstanceID);
    const AAAAMeshlet              meshlet = PullMeshletData(meshletRenderRequest.MeshletID);

    if (!Culling(instanceData, meshlet))
    {
        return;
    }

    uint renderRequestWriteOffset = 0;
    _DestinationMeshletsCounter.InterlockedAdd(0, 1, renderRequestWriteOffset);

    StoreMeshletRenderRequest(_DestinationMeshlets, renderRequestWriteOffset, meshletRenderRequest);
}