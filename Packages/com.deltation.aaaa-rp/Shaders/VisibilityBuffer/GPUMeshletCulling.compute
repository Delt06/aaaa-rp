#pragma kernel CS

#define MESHLET_RENDER_REQUESTS_RW

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAGPUMeshletCulling.cs.hlsl"

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshLOD.hlsl"

#define PLANES_IN_FRUSTUM 6

RWByteAddressBuffer _RequestCounter;
float4              _CameraPosition;
float4              _CameraFrustumPlanes[PLANES_IN_FRUSTUM];

// https://gist.github.com/XProger/6d1fd465c823bba7138b638691831288
// Computes signed distance between a point and a plane
// vPlane: Contains plane coefficients (a,b,c,d) where: ax + by + cz = d
// vPoint: Point to be tested against the plane.
float DistanceToPlane(const float4 plane, const float3 position)
{
    return dot(float4(position, 1.0), plane);
}

bool CullSphere(const float4 planes[PLANES_IN_FRUSTUM], const float3 center, const float radius)
{
    const float dist01 = min(DistanceToPlane(planes[0], center), DistanceToPlane(planes[1], center));
    const float dist23 = min(DistanceToPlane(planes[2], center), DistanceToPlane(planes[3], center));
    const float dist45 = min(DistanceToPlane(planes[4], center), DistanceToPlane(planes[5], center));

    return min(min(dist01, dist23), dist45) + radius > 0;
}

float4 TransformBoundingSphere(const float4 boundingSphereOS, const float4x4 objectToWorldMatrix)
{
    const float3 centerWS = mul(objectToWorldMatrix, float4(boundingSphereOS.xyz, 1)).xyz;
    const float3 topOS = boundingSphereOS.xyz + float3(0, boundingSphereOS.w, 0);
    const float3 topWS = mul(objectToWorldMatrix, float4(topOS, 1)).xyz;
    const float  radiusWS = distance(centerWS, topWS);
    return float4(centerWS, radiusWS);
}

bool ConeCulling(const AAAAInstanceData instanceData, const AAAAMeshlet meshlet)
{
    const float3 coneApexWS = TransformObjectToWorld(meshlet.ConeApexCutoff.xyz, instanceData.ObjectToWorldMatrix);
    const float3 coneAxisWS = TransformObjectToWorldNormal(meshlet.ConeAxis.xyz, instanceData.WorldToObjectMatrix);
    const float  dotResult = dot(normalize(coneApexWS - _CameraPosition.xyz), coneAxisWS);
    // using !>= handles the case when the meshlet's coneAxis is (0, 0, 0)
    // dotResult stores NaN in this case
    return !(dotResult >= meshlet.ConeApexCutoff.w);
}

bool Culling(const AAAAInstanceData instanceData, const AAAAMeshLOD meshLOD, const uint relativeMeshletIndex)
{
    const AAAAMeshlet meshletData = PullMeshletData(meshLOD.MeshletStartOffset + relativeMeshletIndex);
    const float4      boundingSphere = TransformBoundingSphere(meshletData.BoundingSphere, instanceData.ObjectToWorldMatrix);
    return CullSphere(_CameraFrustumPlanes, boundingSphere.xyz, boundingSphere.w) && ConeCulling(instanceData, meshletData);
}

#define MESHLETS_PER_BATCH 1024
#define ITEMS_IN_MESHLET_MASK 32
#define MESHLET_MASKS_PER_BATCH (MESHLETS_PER_BATCH / ITEMS_IN_MESHLET_MASK)

groupshared uint g_MeshletVisibilityMask[MESHLET_MASKS_PER_BATCH];
groupshared uint g_VisibleMeshletsCount;
groupshared uint g_WrittenMeshletsCount;
groupshared uint g_MeshletWriteOffset;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 groupThreadID : SV_GroupThreadID, const uint3 groupID : SV_GroupID)
{
    const uint instanceID = groupID.y;
    if (instanceID >= _InstanceCount)
    {
        return;
    }

    const AAAAInstanceData instanceData = PullInstanceData(instanceID);
    const AAAAMeshLOD      meshLOD = PullMeshLOD(instanceData.MeshLODStartIndex, 0);

    for (uint beginMeshletIndex = 0; beginMeshletIndex < meshLOD.MeshletCount; beginMeshletIndex += MESHLETS_PER_BATCH)
    {
        const uint endMeshletIndex = min(beginMeshletIndex + MESHLETS_PER_BATCH, meshLOD.MeshletCount);

        GroupMemoryBarrierWithGroupSync();

        const uint localThreadIndex = groupThreadID.x;
        for (uint maskIndex = localThreadIndex; maskIndex < MESHLET_MASKS_PER_BATCH; maskIndex += THREAD_GROUP_SIZE)
        {
            g_MeshletVisibilityMask[maskIndex] = 0;
        }

        if (localThreadIndex == 0)
        {
            g_VisibleMeshletsCount = 0;
            g_WrittenMeshletsCount = 0;
        }

        GroupMemoryBarrierWithGroupSync();

        for (uint maskStartMeshletIndex = beginMeshletIndex + localThreadIndex * ITEMS_IN_MESHLET_MASK;
             maskStartMeshletIndex < endMeshletIndex;
             maskStartMeshletIndex += THREAD_GROUP_SIZE * ITEMS_IN_MESHLET_MASK
        )
        {
            uint mask = 0;
            uint count = 0;

            for (uint i = 0; i < ITEMS_IN_MESHLET_MASK; ++i)
            {
                const uint relativeMeshletIndex = maskStartMeshletIndex + i;
                if (relativeMeshletIndex < endMeshletIndex && Culling(instanceData, meshLOD, relativeMeshletIndex))
                {
                    mask |= 1u << i;
                    ++count;
                }
            }

            const uint meshletIndexInBatch = maskStartMeshletIndex - beginMeshletIndex;
            const uint meshletMaskIndex = meshletIndexInBatch / ITEMS_IN_MESHLET_MASK;
            g_MeshletVisibilityMask[meshletMaskIndex] = mask;

            InterlockedAdd(g_VisibleMeshletsCount, count);
        }

        GroupMemoryBarrierWithGroupSync();

        if (localThreadIndex == 0)
        {
            _RequestCounter.InterlockedAdd(0, g_VisibleMeshletsCount, g_MeshletWriteOffset);
        }

        GroupMemoryBarrierWithGroupSync();

        if (g_VisibleMeshletsCount > 0)
        {
            for (uint relativeMeshletIndex = beginMeshletIndex + localThreadIndex; relativeMeshletIndex < endMeshletIndex; relativeMeshletIndex +=
                 THREAD_GROUP_SIZE)
            {
                const uint meshletIndexInBatch = relativeMeshletIndex - beginMeshletIndex;
                const uint meshletMaskIndex = meshletIndexInBatch / ITEMS_IN_MESHLET_MASK;
                const uint meshletMask = 1u << (meshletIndexInBatch % ITEMS_IN_MESHLET_MASK);

                if ((g_MeshletVisibilityMask[meshletMaskIndex] & meshletMask) != 0)
                {
                    uint requestWriteOffset = 0;
                    InterlockedAdd(g_WrittenMeshletsCount, 1, requestWriteOffset);

                    AAAAMeshletRenderRequest meshletRenderRequest;
                    meshletRenderRequest.InstanceID = instanceID;
                    meshletRenderRequest.MeshletID = meshLOD.MeshletStartOffset + relativeMeshletIndex;

                    StoreMeshletRenderRequest(g_MeshletWriteOffset + requestWriteOffset, meshletRenderRequest);
                }
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }
}