#pragma kernel CS

#define MESHLET_RENDER_REQUESTS_RW

#pragma enable_d3d11_debug_symbols

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAGPUMeshletCulling.cs.hlsl"

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"

#define PLANES_IN_FRUSTUM 6

RWByteAddressBuffer _RequestCounter;
float4              _CameraPosition;
float4              _CameraFrustumPlanes[PLANES_IN_FRUSTUM];

// https://gist.github.com/XProger/6d1fd465c823bba7138b638691831288
// Computes signed distance between a point and a plane
// vPlane: Contains plane coefficients (a,b,c,d) where: ax + by + cz = d
// vPoint: Point to be tested against the plane.
float DistanceToPlane(const float4 plane, const float3 position)
{
    return dot(float4(position, 1.0), plane);
}

bool CullSphere(const float4 planes[PLANES_IN_FRUSTUM], const float3 center, const float radius)
{
    const float dist01 = min(DistanceToPlane(planes[0], center), DistanceToPlane(planes[1], center));
    const float dist23 = min(DistanceToPlane(planes[2], center), DistanceToPlane(planes[3], center));
    const float dist45 = min(DistanceToPlane(planes[4], center), DistanceToPlane(planes[5], center));

    return min(min(dist01, dist23), dist45) + radius > 0;
}

float4 TransformBoundingSphere(const float4 boundingSphereOS, const float4x4 objectToWorldMatrix)
{
    const float3 centerWS = mul(objectToWorldMatrix, float4(boundingSphereOS.xyz, 1)).xyz;
    const float3 topOS = boundingSphereOS.xyz + float3(0, boundingSphereOS.w, 0);
    const float3 topWS = mul(objectToWorldMatrix, float4(topOS, 1)).xyz;
    const float  radiusWS = distance(centerWS, topWS);
    return float4(centerWS, radiusWS);
}

bool ConeCulling(const AAAAInstanceData instanceData, const AAAAMeshlet meshlet)
{
    const float3 coneApexWS = TransformObjectToWorld(meshlet.ConeApexCutoff.xyz, instanceData.ObjectToWorldMatrix);
    const float3 coneAxisWS = TransformObjectToWorldNormal(meshlet.ConeAxis.xyz, instanceData.WorldToObjectMatrix);
    const float  dotResult = dot(normalize(coneApexWS - _CameraPosition.xyz), coneAxisWS);
    // using !>= handles the case when the meshlet's coneAxis is (0, 0, 0)
    // dotResult stores NaN in this case
    return !(dotResult >= meshlet.ConeApexCutoff.w);
}

bool Culling(const AAAAInstanceData instanceData, const uint relativeMeshletIndex)
{
    const AAAAMeshlet meshletData = PullMeshletData(instanceData.MeshletStartOffset + relativeMeshletIndex);
    const float4      boundingSphere = TransformBoundingSphere(meshletData.BoundingSphere, instanceData.ObjectToWorldMatrix);
    return CullSphere(_CameraFrustumPlanes, boundingSphere.xyz, boundingSphere.w) && ConeCulling(instanceData, meshletData);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 threadID : SV_DispatchThreadID)
{
    const uint instanceID = threadID.x;
    if (instanceID >= _InstanceCount)
    {
        return;
    }

    const AAAAInstanceData instanceData = PullInstanceData(instanceID);

    for (uint relativeMeshletIndex = 0; relativeMeshletIndex < instanceData.MeshletCount; ++relativeMeshletIndex)
    {
        if (Culling(instanceData, relativeMeshletIndex))
        {
            AAAAMeshletRenderRequest meshletRenderRequest;
            meshletRenderRequest.InstanceID = instanceID;
            meshletRenderRequest.RelativeMeshletID = relativeMeshletIndex;

            uint requestWriteOffset = 0;
            _RequestCounter.InterlockedAdd(0, 1, requestWriteOffset);
            StoreMeshletRenderRequest(requestWriteOffset, meshletRenderRequest);
        }
    }
}