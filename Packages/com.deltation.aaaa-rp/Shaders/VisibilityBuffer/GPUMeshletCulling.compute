#pragma kernel CS

#pragma multi_compile_local _ MAIN_PASS FALSE_NEGATIVE_PASS

#include_with_pragmas "Packages/com.deltation.aaaa-rp/ShaderLibrary/Debug/GPUCullingDebug.hlsl"

#if defined(MAIN_PASS) || defined(FALSE_NEGATIVE_PASS)
#define OCCLUSION_CULLING_ON
#endif

#include "Packages/com.deltation.aaaa-rp/Runtime/Meshlets/AAAAMeshletComputeShaders.cs.hlsl"
#define THREAD_GROUP_SIZE GPUMESHLET_CULLING_THREAD_GROUP_SIZE

#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Core.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/Math.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Instances.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/Meshlets.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/MeshletCulling.hlsl"
#define RW_OCCLUSION_CULLING_INSTANCE_VISIBILITY_MASK
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/VisibilityBuffer/OcclusionCulling.hlsl"

float4   _CameraPosition;
float4   _CameraFrustumPlanes[PLANES_IN_FRUSTUM];
float4x4 _CameraViewProjection;
float4x4 _CameraView;
float4x4 _CameraViewInv;
float    _CameraIsPerspective;

ByteAddressBuffer _SourceMeshletsCounter;
ByteAddressBuffer _SourceMeshlets;

RWByteAddressBuffer _DestinationMeshletsCounter;
RWByteAddressBuffer _DestinationMeshlets;

bool Culling(const AAAAInstanceData instanceData, const AAAAMeshlet meshletData)
{
    const float4           boundingSphere = TransformBoundingSphere(meshletData.BoundingSphere, instanceData.ObjectToWorldMatrix);
    const BoundingSquareSS boundingSquareSS = OcclusionCulling::ComputeScreenSpaceBoundingSquare(boundingSphere, _CameraViewProjection);

    bool result = false;

    UNITY_BRANCH
    if (FrustumVsSphereCulling(_CameraFrustumPlanes, boundingSphere))
    {
        const float3 viewForwardDirWS = GetViewForwardDir(_CameraView);
        const bool isPerspective = _CameraIsPerspective;

        UNITY_BRANCH
        if (ConeCulling(_CameraPosition.xyz, viewForwardDirWS, isPerspective, instanceData, meshletData))
        {
            #if defined(FALSE_NEGATIVE_PASS)
        
            UNITY_BRANCH
            if (OcclusionCulling::IsVisible(boundingSquareSS))
            {
                result = true;
            }
            else
            {
                GPUCullingDebug::OnCulled(boundingSquareSS, AAAAGPUCULLINGDEBUGGRANULARITY_MESHLET, AAAAGPUCULLINGDEBUGTYPE_OCCLUSION);
            }
        
            #else

            result = true;

            #endif
        }
        else
        {
            GPUCullingDebug::OnCulled(boundingSquareSS, AAAAGPUCULLINGDEBUGGRANULARITY_MESHLET, AAAAGPUCULLINGDEBUGTYPE_CONE);
        }
    }
    else
    {
        GPUCullingDebug::OnCulled(boundingSquareSS, AAAAGPUCULLINGDEBUGGRANULARITY_MESHLET, AAAAGPUCULLINGDEBUGTYPE_FRUSTUM);
    }

    return result;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID)
{
    const uint meshletsCount = _SourceMeshletsCounter.Load(0);
    const uint sourceMeshletID = dispatchThreadID.x;

    UNITY_BRANCH
    if (sourceMeshletID >= meshletsCount)
    {
        return;
    }

    const AAAAMeshletRenderRequest meshletRenderRequest = PullMeshletRenderRequest(_SourceMeshlets, sourceMeshletID);
    const AAAAInstanceData         instanceData = PullInstanceData(meshletRenderRequest.InstanceID);
    const AAAAMeshlet              meshlet = PullMeshletData(meshletRenderRequest.MeshletID);

    if (!Culling(instanceData, meshlet))
    {
        return;
    }

    uint renderRequestWriteOffset = 0;
    _DestinationMeshletsCounter.InterlockedAdd(0, 1, renderRequestWriteOffset);

    StoreMeshletRenderRequest(_DestinationMeshlets, renderRequestWriteOffset, meshletRenderRequest);
    #ifdef OCCLUSION_CULLING_ON
    OcclusionCulling::MarkVisibleThisFrame(meshletRenderRequest.InstanceID);
    #endif
}