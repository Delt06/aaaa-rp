#pragma kernel CS

#include "Packages/com.deltation.aaaa-rp/Shaders/ClusteredLighting/Common.hlsl"
#include "Packages/com.deltation.aaaa-rp/ShaderLibrary/PunctualLights.hlsl"

#define THREAD_GROUP_SIZE CLUSTER_CULLING_THREAD_GROUP_SIZE

StructuredBuffer<AAAAClusterBounds> _ClusterBounds;

RWByteAddressBuffer                               _LightIndexCounter;
RWByteAddressBuffer                               _LightIndexList;
RWStructuredBuffer<AAAAClusteredLightingGridCell> _LightGrid;

groupshared AAAAPunctualLightData g_CachedPunctualLights[THREAD_GROUP_SIZE];

void LoadCachedLights(const uint cachedLightIndex, const uint lightIndex)
{
    UNITY_BRANCH
    if (lightIndex < PunctualLightCount)
    {
        g_CachedPunctualLights[cachedLightIndex] = _PunctualLights[lightIndex];
    }
    else
    {
        g_CachedPunctualLights[cachedLightIndex] = (AAAAPunctualLightData)0;
    }
}

float ComputePointToAABBDistanceSq(const float3 pointVS, const AAAAClusterBounds clusterBoundsVS)
{
    float sqDist = 0.0;

    UNITY_UNROLL
    for (int i = 0; i < 3; ++i)
    {
        float v = pointVS[i];
        if (v < clusterBoundsVS.Min[i])
        {
            sqDist += (clusterBoundsVS.Min[i] - v) * (clusterBoundsVS.Min[i] - v);
        }
        if (v > clusterBoundsVS.Max[i])
        {
            sqDist += (v - clusterBoundsVS.Max[i]) * (v - clusterBoundsVS.Max[i]);
        }
    }

    return sqDist;
}

bool CheckPointLightVsClusterAABB(const uint cachedLightIndex, const AAAAClusterBounds clusterBounds)
{
    const float  lightRadius = g_CachedPunctualLights[cachedLightIndex].Color_Radius.w;
    const float3 lightCenterWS = g_CachedPunctualLights[cachedLightIndex].PositionWS.xyz;
    const float3 lightCenterVS = mul(UNITY_MATRIX_V, float4(lightCenterWS, 1.0f)).xyz;
    const float  squaredDistance = ComputePointToAABBDistanceSq(lightCenterVS, clusterBounds);
    return lightRadius > 0 && squaredDistance <= lightRadius * lightRadius;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CS(const uint3 dispatchThreadID : SV_DispatchThreadID, const uint3 groupThreadID : SV_GroupThreadID)
{
    const uint flatClusterIndex = dispatchThreadID.x;
    uint       visibleLightCount = 0;
    uint       visibleLightIndices[MAX_LIGHTS_PER_CLUSTER];

    const AAAAClusterBounds clusterBounds = _ClusterBounds[flatClusterIndex];

    GroupMemoryBarrierWithGroupSync();

    for (uint baseLightIndex = 0; baseLightIndex < PunctualLightCount; baseLightIndex += THREAD_GROUP_SIZE)
    {
        const uint loadedLightIndex = baseLightIndex + groupThreadID.x;
        LoadCachedLights(groupThreadID.x, loadedLightIndex);

        GroupMemoryBarrierWithGroupSync();

        for (uint cachedLightIndex = 0; cachedLightIndex < THREAD_GROUP_SIZE; ++cachedLightIndex)
        {
            if (visibleLightCount < MAX_LIGHTS_PER_CLUSTER && CheckPointLightVsClusterAABB(cachedLightIndex, clusterBounds))
            {
                visibleLightIndices[visibleLightCount++] = baseLightIndex + cachedLightIndex;
            }
        }
    }

    GroupMemoryBarrierWithGroupSync();

    uint indexListOffset;
    _LightIndexCounter.InterlockedAdd(0, visibleLightCount, indexListOffset);

    for (uint i = 0; i < visibleLightCount; ++i)
    {
        const uint indexListAddress = 4 * (indexListOffset + i);
        _LightIndexList.Store(indexListAddress, visibleLightIndices[i]);
    }

    AAAAClusteredLightingGridCell cell;
    cell.Offset = indexListOffset;
    cell.Count = visibleLightCount;
    _LightGrid[flatClusterIndex] = cell;
}